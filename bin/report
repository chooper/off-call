#!/usr/bin/env ruby
# coding: utf-8


require "./lib/off-call"
require "terminal-table"
require "tzinfo"

ENV.source ".env"
ENV["TZ"] = "UTC"

OffCall::PagerDuty.connect(ENV["PAGERDUTY_SUBDOMAIN"], ENV["PAGERDUTY_USER"], ENV["PAGERDUTY_PASSWORD"])

SERVICES  = ENV["SERVICES"].split(",") || abort("Must provide SERVICES=PXXXXXX,PYYYYYY")
SINCE     = ENV["SINCE"].to_time rescue "Last Week".to_time
UNTIL     = ENV["UNTIL"].to_time rescue "Now".to_time

tzmap = {
    "Eastern Time (US & Canada)" => TZInfo::Timezone.get("America/New_York"),
    "Central Time (US & Canada)" => TZInfo::Timezone.get("America/Chicago"),
    "Pacific Time (US & Canada)" => TZInfo::Timezone.get("America/Los_Angeles"),
    "Atlantic Time (Canada)" => TZInfo::Timezone.get("America/Halifax"),
    "Madrid" => TZInfo::Timezone.get("Europe/Madrid"),
    "UTC" => TZInfo::Timezone.get("UTC")
}   

incidents = []
SERVICES.each do |service_id|
  s = OffCall::PagerDuty::Service.new(service_id)
  incidents += s.incidents(since: SINCE, until: UNTIL)
end

subjects  = {}
resolvers = {}
hours     = Hash[(0..23).zip [0]*24]
days      = Hash[%w(Mon Tue Wed Thu Fri Sat Sun ).zip [0]*7]

incidents.each do |i|
  # normalize instance-type-id/Service
  k = ((i["trigger_summary_data"] && i["trigger_summary_data"]["subject"]) || i["incident_key"]).
        gsub(/^([a-z_-]+)-([0-9]+)(.(?:heroku|heroku-b|ops.herokai)?.com)(\/[^:]+|$)/, "\\1-XXXXX\\3\\4").
        gsub(/^(canary:) (\w+) (\w+) (\d+)/, "\\1 \\2 \\3 N").
        gsub(/^(face-)(\d+\.\d+\.\d+\.\d+)$/, "\\1a.b.c.d").
        trunc(90)
  subjects[k] ||= 0
  subjects[k]  += 1

  k = i["last_status_change_by"]["name"] rescue "Nobody"
  resolvers[k] ||= 0
  resolvers[k]  += 1

  k = i["last_status_change_on"].to_time.hour
  hours[k] ||= 0
  hours[k]  += 1

  k = i["last_status_change_on"].to_time.strftime("%a")
  days[k] ||= 0
  days[k]  += 1
end

alerts = OffCall::PagerDuty.alerts(since: SINCE, until: UNTIL)
users = {}
sms_by_hour = Hash[(0..23).zip [0]*24]
exclude_users = Set.new ['Edward Muller', 'Routing Monkey', 'Scott Clasen', 'Peter van Hardenberg', 'Daniel Farina', 'Will Leinweber', 'Ryan Smith', 'Mark McGranaghan', 'Harold Gim√©nez', 'Phil Ripperger', 'John Simone', 'Glenn Gillen', 'Chris Stolt', 'Max Schoening', 'Mark Pundsack', 'Dominic Dagradi', 'JD', 'Maciek Sakrejda', 'Naaman Newbold', 'Mattt Thompson', 'Caio Chassot', 'Matthew Manning', 'Ryan Brainard']

alerts.each do |alert|
  userid = alert["user"]["id"]
  users[userid] ||= alert["user"]
  users[userid]["num_sms"] ||= 0
  users[userid]["num_phone"] ||= 0

  tz = users[userid]["time_zone"]
  abort("Unknown time zone: "+ tz) unless tzmap.include? tz

  started = alert["started_at"].to_time
  local_hour = tzmap[tz].utc_to_local(started).hour

  next if exclude_users.include? users[userid]["name"]
  if alert["type"] == "SMS"
    users[userid]["num_sms"] += 1
    sms_by_hour[local_hour] ||= 0
    sms_by_hour[local_hour] += 1
  elsif alert["type"] == "Phone"
    users[userid]["num_phone"] += 1
  end
end

puts "# Summary for #{SINCE} to #{UNTIL}"
puts

puts
puts "## Incident types by frequency"
puts

Terminal::Table.new do |t|
  t.headings = "Subject", "Count"
  t.rows     = subjects.sort { |a,b| b[1]<=>a[1] }
  t << :separator  
  t << ["TOTAL", subjects.inject(0) { |s,h| s += h[1] } ]
  t << ["DISTINCT", subjects.inject(0) { |s,h| s += 1 } ]
  puts t
end

puts
puts "## Alerts by person"
puts

Terminal::Table.new do |t|
  t.headings = "User", "SMS count", "Phone count"

  user_sms_phone = []
  users.each do |userid,user|
    next unless user["num_sms"] > 0 or user["num_phone"] > 0
    user_sms_phone << [user["name"], user["num_sms"], user["num_phone"]]
  end
  
  t.rows     = user_sms_phone.sort { |a,b| b[1]<=>a[1] }
  t << :separator  
  total_users = user_sms_phone.length
  total_phone, total_sms = user_sms_phone.inject([0,0]) do |s,h|
    s[0] += h[1]
    s[1] += h[2]
    s
  end

  t << ["#{total_users} users", total_phone, total_sms]

  puts t
end

puts
puts "## Incidents resolved by person"
puts

Terminal::Table.new do |t|
  t.headings = "Resolved By", "Count"
  t.rows     = resolvers.sort { |a,b| b[1]<=>a[1] }
  puts t
end

puts
puts "## Incidents by hour (PagerDuty time)"
puts

Terminal::Table.new do |t|
  t.headings = "Hour", "Count"

  hours.each do |k,v|
    t << :separator if [3, 15].include? k # 8 PM and 8 AM PDT
    t << [k,v]
  end

  puts t
end

puts
puts "## SMS alerts by hour (local time)"
puts

Terminal::Table.new do |t|
  t.headings = "Hour", "Count"

  business_hours = [8, 19] # 7 PM and 8 AM local time
  off_hours_sms = 0
  sms_by_hour.each do |k,v|
    if k > business_hours[1] or k < business_hours[0]
      off_hours_sms += v
    end

    t << :separator if business_hours.include? k # demarcate business hours
    t << [k,v]
  end

  t << :separator
  t << ["After hours (#{business_hours[1]}-#{business_hours[0]})", off_hours_sms]

  puts t
end

puts
puts "## Incidents by day"
puts

Terminal::Table.new do |t|
  t.headings = "Day", "Count"

 days.each do |k,v|
    t << [k,v]
    t << :separator if k == "Fri"
  end

  puts t
end
